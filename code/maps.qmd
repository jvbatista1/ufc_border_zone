---
title: "Mapas e análise exploratória dos dados"
author: "Victor Batista"
format: html
editor: visual
---

# Introdução

Configura pacotes, diretórios e insere os dados

```{r wd, include=FALSE}
dropbox <- "c:/Users/victo/dropbox/DISSERTACAO/"
```

```{r libraries, include=FALSE}
packages <- c("sf",
              "SpatialRDD",
              "tidyverse",
              "stargazer",
              "tmap",
              "rdrobust",
              "rddapp",
              "lfe",
              "geobr",
              "summarytools",
              "kableExtra",
              "gifski",
              "readxl")
lapply(packages, require, character.only = TRUE)
rm(packages)
```

```{r input, include=FALSE}
#source?
border_data <- read_excel(file.path(dropbox,"Base_homicidios.xlsx"))
glimpse(border_data)

```

```{r include=FALSE}
border_data <- border_data |> 
  separate(Município, c("code_muni", "name_muni"), sep = 7) |> 
  separate(code_muni, c("code_muni", NA), sep = -1) |> 
  dplyr::select(-name_muni)
```

# Mapas

## Lê os shapefiles

```{r shapefilefronteira, echo=TRUE, warning=FALSE}
fronteira <- st_read(file.path(dropbox,"Fronteira/Faixa_de_Fronteira_por_UF_2022.shp")) %>%
  st_transform("WGS84")

tm_shape(fronteira, unit = "km")+
  tm_fill(alpha = 0.7) + 
  tm_borders(col = "black")
```

## Uniformiza a faixa de fronteira como uma única região

```{r sflinha, echo=TRUE, warning=FALSE}
linha_fronteira <- fronteira %>%
  mutate(pais = "BR") %>% 
  group_by(pais) %>% 
  summarise()

tm_shape(linha_fronteira, unit = "km")+
  tm_fill(alpha = 0.7) + 
  tm_borders(col = "black")
```

## Carrega sf dos municípios brasileiros

```{r sfmunicipios, echo=TRUE, warning=FALSE}
municipios <- read_municipality(year=2020, showProgress = T) %>%
  st_transform("WGS84")

tm_shape(municipios, unit = "km")+
  tm_fill(alpha = 0.7) + 
  tm_borders(col = "black")
```

## Carrega o sf dos países da América do Sul

```{r sfamerica, echo=TRUE, warning=FALSE}
america <- st_read(file.path(dropbox,"America/South_America.shp")) %>% 
  st_transform("WGS84")

tm_shape(america, unit = "km")+
  tm_fill(alpha = 0.7) + 
  tm_borders(col = "black")
```

## Carrega o sf dos municípios da faixa de fronteira

```{r sfmunicipiosff, echo=TRUE, warning=FALSE}
municipios_fronteira <- st_read(file.path(dropbox,"Municipios_Fronteira/Municipios_Faixa_Fronteira_2022.shp")) %>%
  st_transform("WGS84")

tm_shape(municipios_fronteira, unit = "km")+
  tm_fill(alpha = 0.7) + 
  tm_borders(col = "black")
```

## Novos municípios propostos

```{r}
# Estabelece a nova proposta de faixa de fronteira
linha_fronteira_300km <- st_buffer(linha_fronteira, dist = 150000)

# Verifica municípios que passam a pertencer à região
# Adiciona variável de intercessão
municipios$inter <- st_intersects(municipios, linha_fronteira_300km, sparse = F)
table(municipios$inter)

```

## Faixa de fronteira original

```{r}
# Adiciona variável de pertencimento à fronteira original
municipios <- municipios %>%
  mutate(fronteira = ifelse(code_muni %in% municipios_fronteira$CD_MUN, 1, 0))
table(municipios$fronteira)
```

# Criação de tratamento e controle

```{r}
df <- municipios |>
  #filtra os municípios na nova faixa
  filter(inter == T) |> 
  # cria o grupo de tratamento e controle
  mutate(treated = ifelse(code_muni %in% municipios_fronteira$CD_MUN, 1, 0),
         groups = ifelse(treated == 1, "treatment", "control"),
         # cria os arcos
         arcos = case_when(abbrev_state %in% c("AP", "PA", "AM", "AC", "RR") ~ "Arco Norte",
                           abbrev_state %in% c("RO", "MS", "MT") ~ "Arco Central",
                           abbrev_state %in% c("PR", "SC", "RS") ~ "Arco Sul")) |> 
  # exclui a variável classificatória. as recém criadas a substituem
  dplyr::select(-inter)

glimpse(df)

```

```{r}
# prepara a tabela da fronteira para mergir com a df principal (municipios)
t <- municipios_fronteira |> 
  # remove colunas indesejadas
  select(-c("NM_REGIAO", "CD_UF", "NM_UF", "SIGLA_UF", "NM_MUN", "geometry")) |> 
  # padroniza o nome code_muni
  rename("code_muni" = "CD_MUN") |> 
  # altera o tipo das colunas para numeric e logic
  mutate(code_muni = as.numeric(code_muni),
         CID_GEMEA = ifelse(is.na(CID_GEMEA) == F, 1, 0))

# remove o componente gráfico
st_geometry(t) <- NULL

# realiza o join
df <- dplyr::left_join(df, t, by = "code_muni")
rm(t)

glimpse(df)
```

```{r}
# prepara a tabela da sede dos mun da faixa da fronteira para mergir com a df principal (municipios)
sede_municipios <- st_read(file.path(dropbox,"Sedes_Municipios_Faixa_de_Fronteira_Cidades_Gemeas_2022_shp/Sedes_Municipios_Faixa_de_Fronteira_Cidades_Gemeas_2022.shp")) %>%
  st_transform("WGS84")

t <- sede_municipios %>%
  # seleciona colunas desejadas
  select(c("CD_MUN", "FAIXA_SEDE")) %>%
  # harmoniza os nomes de variáveis
  rename("code_muni" = "CD_MUN") %>%
  # modifica a classe da variável
  mutate(code_muni = as.numeric(code_muni),
         FAIXA_SEDE = ifelse(FAIXA_SEDE == "sim", 1, 0))

# remove a geometria da tabela para realizar o join
st_geometry(t) <- NULL

# realiza o join
df <- dplyr::left_join(df, t, by = "code_muni")
rm(t)

glimpse(df)
```

```{r}
# prepara para juntar demais países da américa do sul na base de municípios
# Remove regiões sem fronteira com o br
america2 <- america %>%
  filter(!(COUNTRY %in% c("Brazil", "Falkland Islands (UK)",
                          "South Georgia and the South Sandwich Is (UK)", "Chile", "Ecuador")))

# verifica interseções
a <- st_intersects(df, america2, sparse = FALSE)

# renomeia colunas e cria variáveis dummy
a <- as.data.frame(a) %>%
  rename("Argentina" = "V1",
         "Bolivia" = "V2",
         "Colombia" = "V3",
         "French_Guiana" = "V4",
         "Guyana" = "V5",
         "Suriname" = "V6",
         "Paraguay" = "V7",
         "Peru" = "V8",
         "Uruguay" = "V9",
         "Venezuela" = "V10") %>%
  mutate(Argentina = ifelse(Argentina == T, 1, 0),
         Bolivia = ifelse(Bolivia == T, 1, 0),
         Colombia = ifelse(Colombia == T, 1, 0),
         French_Guiana = ifelse(French_Guiana == T, 1, 0),
         Guyana = ifelse(Guyana == T, 1, 0),
         Suriname = ifelse(Suriname == T, 1, 0),
         Paraguay = ifelse(Paraguay == T, 1, 0),
         Peru = ifelse(Peru == T, 1, 0),
         Uruguay = ifelse(Uruguay == T, 1, 0),
         Venezuela = ifelse(Venezuela == T, 1, 0))

df <- cbind(df, a)
rm(a)

glimpse(df)

```

# Mapas

## Mapa por grupos

```{r}
tm_shape(df) + tm_polygons(col = "groups")
```

## Mapa por arcos

```{r}
tm_shape(df) + tm_polygons(col = "arcos")
```

# Análise exploratória

```{r}
base_homicidios <- read_excel(file.path(dropbox, "Base_homicidios.xlsx"))
base_homicidios <- base_homicidios %>%
  separate(Município, c("code_muni", "name_muni"), sep = 7) %>%
  separate(code_muni, c("code_muni", NA), sep = -1) %>%
  select(-name_muni)

base_homicidios

```

```{r}
# separar em dois, porque o tidyverse não funciona bem com arquivos espaciais
df_rdd <- df %>%
  separate(code_muni, c("code_muni", NA), sep = -1)

df_rdd <- left_join(df_rdd, base_homicidios, by = "code_muni") %>%
  mutate(`Porcentagem_Homens_Jovens` = as.numeric(`Porcentagem_Homens_Jovens`))

glimpse(df_rdd)
```

```{r, include=FALSE}
df_rdd <- df_rdd |> 
  mutate(
   code_muni = as.character(code_muni),
   name_muni = as.character(name_muni),
   code_state = as.character(code_state),
   abbrev_state = as.character(abbrev_state),
   name_state = as.character(name_state),
   code_region = as.character(code_region),
   name_region = as.character(name_region),
   fronteira = as.logical(fronteira),
   treated = as.logical(treated),
   groups = as.character(groups),
   arcos = as.character(arcos),
   AREA_TOT = as.character(AREA_TOT),
   AREA_INT = as.character(AREA_INT),
   PORC_INT = as.character(PORC_INT),
   CID_GEMEA = as.logical(CID_GEMEA),
   FAIXA_SEDE = as.logical(FAIXA_SEDE),
   Argentina = as.logical(Argentina),
   Bolivia = as.logical(Bolivia),
   Colombia = as.logical(Colombia),
   French_Guiana = as.logical(French_Guiana),
   Guyana = as.logical(Guyana),
   Suriname = as.logical(Suriname),
   Paraguay = as.logical(Paraguay),
   Peru = as.logical(Peru),
   Uruguay = as.logical(Uruguay),
   Venezuela = as.logical(Venezuela)
  )
```

## Estatísticas descritivas

```{r, include=FALSE}
library(skimr)
library(GGally)
```

```{r, echo=TRUE, warning=FALSE}
skim(df_rdd)

```

```{r}
ggplot(df, aes(x = groups)) +
  
  geom_bar(fill = "skyblue", color = "black") +
  ggtitle("Distribuição dos Grupos (Tratamento vs Controle)")

```

## Histogramas

```{r}
# Gráfico de distribuição da Taxa de Analfabetismo para tratamento e controle
ggplot(df_rdd, aes(x = Taxa_de_analfabetismo, fill = groups)) +
  geom_histogram(aes(y = ..density..), position = 'identity', bins = 30, alpha = 0.5, color = "black") +
  geom_density(aes(color = groups), size = 1, fill = NA) +
  scale_fill_manual(values = c("treatment" = "blue", "control" = "red")) +
  scale_color_manual(values = c("treatment" = "blue", "control" = "red")) +
  ggtitle("Distribuição da Taxa de Analfabetismo por Grupo (Tratamento vs Controle)") +
  theme_minimal() +
  labs(x = "Taxa de Analfabetismo", y = "Densidade", fill = "Grupo", color = "Grupo")
```

```{r}
# Boxplot comparando Taxa de Analfabetismo entre grupos
ggplot(df_rdd, aes(x = groups, y = Taxa_de_analfabetismo)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  ggtitle("Taxa de Analfabetismo por Grupo")

# Correlação entre variáveis socioeconômicas
correlation_matrix <- df_rdd

st_geometry(correlation_matrix) <- NULL

correlation_matrix <- correlation_matrix |> 
  select(Taxa_de_analfabetismo, `Taxa_de_desemprego_16a_e+`, Gini, PIB_per_capita) |>  
  cor()

# Heatmap da matriz de correlação
ggcorr(correlation_matrix, label = TRUE) +
  ggtitle("Matriz de Correlação")

```

```{r}
# Scatter plot entre PIB per capita e Gini
ggplot(df_rdd, aes(x = PIB_per_capita, y = Gini, color = groups)) +
  geom_point(size = 2) +
  ggtitle("PIB per capita vs Gini por Grupo")

# Boxplot de Taxa de desemprego por grupo
ggplot(df_rdd, aes(x = groups, y = `Taxa_de_desemprego_16a_e+`)) +
  geom_boxplot(fill = "skyblue", color = "black") +
  ggtitle("Taxa de Desemprego por Grupo")

```

## Taxa de homicídios

```{r}
# Selecionar colunas de interesse
taxa_homicidios <- df_rdd |> 
  select(`valor-2010`:`valor-2019`)

# Calcular estatísticas descritivas
summary_stats <- taxa_homicidios  |> 
  summary()

summary_stats

```

```{r}
# Criar histogramas para cada ano
taxa_homicidios_long <- df_rdd %>% 
  select(code_muni, groups, `valor-2010`:`valor-2019`) %>%
  pivot_longer(cols = `valor-2010`:`valor-2019`, names_to = "year", values_to = "taxa_homicidio")

ggplot(taxa_homicidios_long, aes(x = taxa_homicidio, fill = groups)) +
  geom_histogram(position = 'identity', bins = 30, alpha = 0.5, color = "black") +
  facet_wrap(~ year, scales = "free_x") +
  scale_fill_manual(values = c("treatment" = "blue", "control" = "red")) +
  ggtitle("Distribuição das Taxas de Homicídio de 2010 a 2019") +
  theme_minimal() +
  labs(x = "Taxa de Homicídio", y = "Frequência", fill = "Grupo")

```

```{r}
# Criar gráfico de linhas para tendências temporais
ggplot(taxa_homicidios_long, aes(x = year, y = taxa_homicidio, group = code_muni, color = groups)) +
  geom_line(alpha = 0.3) +
  geom_smooth(method = "loess", se = FALSE, size = 1) +
  scale_color_manual(values = c("treatment" = "blue", "control" = "red")) +
  ggtitle("Tendências das Taxas de Homicídio de 2010 a 2019 por Grupo") +
  theme_minimal() +
  labs(x = "Ano", y = "Taxa de Homicídio", color = "Grupo")

```

```{r}
# Criar boxplots para comparar grupos
ggplot(taxa_homicidios_long, aes(x = year, y = taxa_homicidio, fill = groups)) +
  geom_boxplot(alpha = 0.5) +
  scale_fill_manual(values = c("treatment" = "blue", "control" = "red")) +
  ggtitle("Comparação das Taxas de Homicídio de 2010 a 2019 por Grupo") +
  theme_minimal() +
  labs(x = "Ano", y = "Taxa de Homicídio", fill = "Grupo")

```

```{r}
# Criar um mapa para um ano específico, por exemplo, 2019
ggplot(df_rdd) +
  geom_sf(aes(fill = `valor-2019`), color = NA) +
  scale_fill_viridis_c(option = "plasma", na.value = "grey90", name = "Taxa de Homicídio") +
  ggtitle("Taxa de Homicídios por Município em 2019") +
  theme_minimal() +
  theme(legend.position = "right")

```

```{r}
# Criar uma série de mapas para diferentes anos
years1 <- 2010:2013
plots1 <- lapply(years1, function(year) {
  ggplot(df_rdd) +
    geom_sf(aes_string(fill = paste0("`valor-", year, "`")), color = NA) +
    scale_fill_viridis_c(option = "plasma", na.value = "grey90", name = paste("Taxa de Homicídio", year)) +
    ggtitle(paste("Taxa de Homicídios,", year)) +
    theme_minimal() +
    theme(legend.position = "right")
})

years2 <- 2014:2017
plots2 <- lapply(years2, function(year) {
  ggplot(df_rdd) +
    geom_sf(aes_string(fill = paste0("`valor-", year, "`")), color = NA) +
    scale_fill_viridis_c(option = "plasma", na.value = "grey90", name = paste("Taxa de Homicídio", year)) +
    ggtitle(paste("Taxa de Homicídios,", year)) +
    theme_minimal() +
    theme(legend.position = "right")
})

years3 <- 2018:2019
plots3 <- lapply(years3, function(year) {
  ggplot(df_rdd) +
    geom_sf(aes_string(fill = paste0("`valor-", year, "`")), color = NA) +
    scale_fill_viridis_c(option = "plasma", na.value = "grey90", name = paste("Taxa de Homicídio", year)) +
    ggtitle(paste("Taxa de Homicídios,", year)) +
    theme_minimal() +
    theme(legend.position = "right")
})

# Mostrar todos os mapas em uma grade
library(gridExtra)
do.call(grid.arrange, c(plots1, ncol = 2))
do.call(grid.arrange, c(plots2, ncol = 2))
do.call(grid.arrange, c(plots3, ncol = 2))


```

```{r}
library(ggpattern)

# Criar o mapa com diferenciação visual entre tratamento e controle
ggplot(df_rdd) +
  geom_sf_pattern(aes(fill = `valor-2019`, pattern = groups), 
                  size = 0.2, pattern_density = 0.1) +
  scale_fill_viridis_c(option = "plasma", na.value = "grey90", name = "Taxa de Homicídio") +
  scale_pattern_manual(values = c("control" = "stripe", "treatment" = "circle")) +
  ggtitle("Taxa de Homicídios por Município em 2019") +
  theme_minimal() +
  theme(legend.position = "right")

```
